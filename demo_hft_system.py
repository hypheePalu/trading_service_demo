#!/usr/bin/env python3
"""
HFT Cryptocurrency Arbitrage System - Demo Script

This demo showcases a production-grade high-frequency trading system for
cryptocurrency arbitrage without requiring external dependencies or exposing
sensitive credentials.

Architecture Overview:
- Event-driven async system using simulated message queue
- Multi-exchange arbitrage detection (Binance Futures vs MAX Spot)
- EWMA-based spread analysis for signal generation
- Real-time order management with latency tracking
- Position management across strategies

Author: Demo Version for Interview Presentation
"""

import asyncio
import random
import time
from dataclasses import dataclass, asdict
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Tuple
from collections import deque
import statistics


# ============================================================================
# CONFIGURATION & ENUMS (Production-like structure without sensitive data)
# ============================================================================

class Exchange(Enum):
    BINANCE = "binance"
    MAX = "max"
    TAIWAN_BANK = "taiwan_bank"


class OrderSide(Enum):
    BUY = "buy"
    SELL = "sell"


class OrderStatus(Enum):
    NEW = "new"
    FILLED = "filled"
    PARTIALLY_FILLED = "partially_filled"
    CANCELLED = "cancelled"


class WalletType(Enum):
    SPOT = "spot"
    MARGIN = "margin"


class Strategy(Enum):
    ARBITRAGE = "arbitrage"
    STABLE_COIN = "stable_coin"


# ============================================================================
# DATA MODELS (Strongly-typed messages, production pattern)
# ============================================================================

@dataclass
class L1BookUpdate:
    """Level 1 market data update (best bid/ask)"""
    symbol: str
    exchange: str
    bid_px: float
    bid_sz: float
    ask_px: float
    ask_sz: float
    timestamp: int


@dataclass
class Signal:
    """Trading signal generated by arbitrage scanner"""
    symbol: str
    side: OrderSide
    expected_spread: float
    attempted_price: float
    lead_price: float
    lag_price: float
    strategy: Strategy
    timestamp: int
    ewma_spread: Optional[float] = None


@dataclass
class Order:
    """Order representation"""
    order_id: str
    symbol: str
    side: OrderSide
    price: float
    quantity: float
    status: OrderStatus
    filled_quantity: float = 0.0
    average_price: float = 0.0
    created_ts: int = 0
    filled_ts: Optional[int] = None
    latency_ms: Optional[float] = None


@dataclass
class Position:
    """Position tracking per strategy"""
    strategy: Strategy
    symbol: str
    quantity: float
    average_price: float
    unrealized_pnl: float = 0.0


# ============================================================================
# MOCK MESSAGE QUEUE (Simulates NATS without external dependency)
# ============================================================================

class MockMessageQueue:
    """
    Simulated message queue mimicking NATS pub/sub pattern.
    In production, this uses NATS with JetStream for persistence.
    """

    def __init__(self):
        self.subscribers: Dict[str, List] = {}
        self.message_count = 0

    async def publish(self, topic: str, message: dict):
        """Publish message to topic"""
        self.message_count += 1
        if topic in self.subscribers:
            for handler in self.subscribers[topic]:
                await handler(topic, message)

    async def subscribe(self, topic: str, handler):
        """Subscribe to topic with handler callback"""
        if topic not in self.subscribers:
            self.subscribers[topic] = []
        self.subscribers[topic].append(handler)


# ============================================================================
# MOCK DATA FEEDS (Simulates exchange WebSocket connections)
# ============================================================================

class MockDataFeed:
    """
    Simulates real-time market data from exchanges.
    In production, connects to exchange WebSocket APIs.
    """

    def __init__(self, exchange: Exchange, symbol: str, base_price: float, mq: MockMessageQueue):
        self.exchange = exchange
        self.symbol = symbol
        self.base_price = base_price
        self.current_price = base_price
        self.mq = mq
        self.running = False

        # Realistic price movement parameters
        self.volatility = 0.0001  # 0.01% volatility
        self.tick_size = 0.01

    async def start(self):
        """Start generating market data"""
        self.running = True
        print(f"[{self.exchange.value.upper()}] Starting data feed for {self.symbol}")

        while self.running:
            # Simulate realistic price movement (Brownian motion)
            change_pct = random.gauss(0, self.volatility)
            self.current_price *= (1 + change_pct)
            self.current_price = round(self.current_price / self.tick_size) * self.tick_size

            # Add small bid-ask spread
            spread = self.current_price * 0.0001  # 1 bps spread
            bid_price = self.current_price - spread / 2
            ask_price = self.current_price + spread / 2

            # Create L1 book update
            update = L1BookUpdate(
                symbol=self.symbol,
                exchange=self.exchange.value,
                bid_px=bid_price,
                bid_sz=random.uniform(1.0, 10.0),
                ask_px=ask_price,
                ask_sz=random.uniform(1.0, 10.0),
                timestamp=int(time.time() * 1000)
            )

            # Publish to message queue
            topic = f"exchange.{self.exchange.value}.l1book.{self.symbol}"
            await self.mq.publish(topic, asdict(update))

            # Update frequency: 100ms (10 updates/sec)
            await asyncio.sleep(0.1)

    def stop(self):
        """Stop data feed"""
        self.running = False


# ============================================================================
# ARBITRAGE SCANNER (Core trading logic - EWMA based)
# ============================================================================

class ArbitrageScanner:
    """
    EWMA-based arbitrage detection across exchanges.

    Strategy:
    1. Track price spread between lead (Binance) and lag (MAX) exchanges
    2. Calculate Exponentially Weighted Moving Average of spread
    3. Generate signals when current spread deviates from EWMA by threshold
    4. Use timestamp synchronization to ensure data freshness
    """

    def __init__(self,
                 symbol: str,
                 lead_exchange: Exchange,
                 lag_exchange: Exchange,
                 threshold: float,
                 mq: MockMessageQueue):
        self.symbol = symbol
        self.lead_exchange = lead_exchange
        self.lag_exchange = lag_exchange
        self.threshold = threshold
        self.mq = mq

        # Price tracking
        self.prices: Dict[str, Optional[float]] = {
            lead_exchange.value: None,
            lag_exchange.value: None
        }
        self.timestamps: Dict[str, Optional[int]] = {
            lead_exchange.value: None,
            lag_exchange.value: None
        }

        # EWMA parameters
        self.ewma_alpha = 0.1  # Weight for new observations
        self.ewma_spread: Optional[float] = None

        # Statistics
        self.signals_generated = 0
        self.spread_history = deque(maxlen=100)

    async def start(self):
        """Start listening for price updates"""
        # Subscribe to both exchanges
        await self.mq.subscribe(
            f"exchange.{self.lead_exchange.value}.l1book.{self.symbol}",
            self._handle_price_update
        )
        await self.mq.subscribe(
            f"exchange.{self.lag_exchange.value}.l1book.{self.symbol}",
            self._handle_price_update
        )

        print(f"[SCANNER] Monitoring {self.symbol} arbitrage: "
              f"{self.lead_exchange.value.upper()} vs {self.lag_exchange.value.upper()}")

    async def _handle_price_update(self, topic: str, message: dict):
        """Process incoming price updates"""
        update = L1BookUpdate(**message)

        # Calculate mid price
        mid_price = (update.bid_px + update.ask_px) / 2

        # Update price tracking
        self.prices[update.exchange] = mid_price
        self.timestamps[update.exchange] = update.timestamp

        # Check if we have both prices
        await self._check_arbitrage_opportunity()

    async def _check_arbitrage_opportunity(self):
        """Analyze spread and generate signals"""
        # Ensure we have both prices
        lead_price = self.prices[self.lead_exchange.value]
        lag_price = self.prices[self.lag_exchange.value]
        lead_ts = self.timestamps[self.lead_exchange.value]
        lag_ts = self.timestamps[self.lag_exchange.value]

        if not all([lead_price, lag_price, lead_ts, lag_ts]):
            return

        # Check timestamp freshness (within 3 seconds)
        if abs(lead_ts - lag_ts) > 3000:
            return

        # Calculate spread (percentage)
        current_spread = (lead_price - lag_price) / lag_price
        self.spread_history.append(current_spread)

        # Update EWMA
        if self.ewma_spread is None:
            self.ewma_spread = current_spread
        else:
            self.ewma_spread = (self.ewma_alpha * current_spread +
                               (1 - self.ewma_alpha) * self.ewma_spread)

        # Signal generation logic
        spread_deviation = current_spread - self.ewma_spread

        if abs(spread_deviation) > self.threshold:
            # Determine side
            side = OrderSide.BUY if spread_deviation > 0 else OrderSide.SELL

            # Create signal
            signal = Signal(
                symbol=self.symbol,
                side=side,
                expected_spread=current_spread,
                attempted_price=lag_price,
                lead_price=lead_price,
                lag_price=lag_price,
                strategy=Strategy.ARBITRAGE,
                timestamp=int(time.time() * 1000),
                ewma_spread=self.ewma_spread
            )

            # Publish signal
            await self.mq.publish(f"signal.{self.symbol}", asdict(signal))

            self.signals_generated += 1

            # Visual feedback
            emoji = "🟢" if side == OrderSide.BUY else "🔴"
            print(f"\n{emoji} SIGNAL DETECTED - {side.value.upper()}")
            print(f"   Spread: {current_spread*100:.4f}% | EWMA: {self.ewma_spread*100:.4f}%")
            print(f"   Deviation: {spread_deviation*100:.4f}% (threshold: {self.threshold*100:.2f}%)")
            print(f"   Lead: ${lead_price:.2f} | Lag: ${lag_price:.2f}")


# ============================================================================
# ORDER MANAGER (Execution & latency tracking)
# ============================================================================

class OrderManager:
    """
    Manages order execution and tracks latency metrics.

    In production:
    - Connects to exchange REST APIs
    - Implements retry logic and error handling
    - Tracks order state across multiple exchanges
    - Monitors fill rates and execution quality
    """

    def __init__(self, mq: MockMessageQueue):
        self.mq = mq
        self.orders: Dict[str, Order] = {}
        self.latencies: List[float] = []
        self.orders_filled = 0

    async def start(self):
        """Start listening for signals"""
        await self.mq.subscribe("signal.*", self._handle_signal)
        print("[ORDER MGR] Ready to execute orders")

    async def _handle_signal(self, topic: str, message: dict):
        """Process trading signal and execute order"""
        signal = Signal(**message)

        # Create order
        order_id = f"ORD_{int(time.time() * 1000)}"
        order = Order(
            order_id=order_id,
            symbol=signal.symbol,
            side=signal.side,
            price=signal.attempted_price,
            quantity=100.0,  # Demo quantity
            status=OrderStatus.NEW,
            created_ts=signal.timestamp
        )

        self.orders[order_id] = order

        print(f"\n📤 ORDER PLACED - {order_id}")
        print(f"   {signal.side.value.upper()} {order.quantity} {signal.symbol} @ ${order.price:.2f}")

        # Simulate order execution (50-200ms latency)
        await asyncio.sleep(random.uniform(0.05, 0.2))

        # Fill order
        order.status = OrderStatus.FILLED
        order.filled_quantity = order.quantity
        order.average_price = order.price
        order.filled_ts = int(time.time() * 1000)
        order.latency_ms = (order.filled_ts - order.created_ts)

        self.latencies.append(order.latency_ms)
        self.orders_filled += 1

        print(f"✅ ORDER FILLED - {order_id}")
        print(f"   Latency: {order.latency_ms:.2f}ms")

        # Publish order update
        await self.mq.publish(f"order.{signal.symbol}", asdict(order))

    def get_stats(self) -> dict:
        """Get execution statistics"""
        if not self.latencies:
            return {
                "orders_filled": 0,
                "avg_latency_ms": 0,
                "p50_latency_ms": 0,
                "p95_latency_ms": 0,
                "p99_latency_ms": 0
            }

        sorted_latencies = sorted(self.latencies)
        return {
            "orders_filled": self.orders_filled,
            "avg_latency_ms": statistics.mean(self.latencies),
            "p50_latency_ms": sorted_latencies[len(sorted_latencies)//2],
            "p95_latency_ms": sorted_latencies[int(len(sorted_latencies)*0.95)],
            "p99_latency_ms": sorted_latencies[int(len(sorted_latencies)*0.99)]
        }


# ============================================================================
# POSITION MANAGER (Portfolio tracking)
# ============================================================================

class PositionManager:
    """
    Tracks positions across strategies and calculates P&L.
    """

    def __init__(self, mq: MockMessageQueue):
        self.mq = mq
        self.positions: Dict[str, Position] = {}

    async def start(self):
        """Start listening for order fills"""
        await self.mq.subscribe("order.*", self._handle_order_fill)
        print("[POSITION MGR] Tracking positions")

    async def _handle_order_fill(self, topic: str, message: dict):
        """Update positions based on filled orders"""
        order = Order(**message)

        if order.status != OrderStatus.FILLED:
            return

        key = f"{order.symbol}_{Strategy.ARBITRAGE.value}"

        if key not in self.positions:
            self.positions[key] = Position(
                strategy=Strategy.ARBITRAGE,
                symbol=order.symbol,
                quantity=0.0,
                average_price=0.0
            )

        position = self.positions[key]

        # Update position
        if order.side == OrderSide.BUY:
            new_qty = position.quantity + order.filled_quantity
            position.average_price = (
                (position.average_price * position.quantity +
                 order.average_price * order.filled_quantity) / new_qty
            )
            position.quantity = new_qty
        else:  # SELL
            position.quantity -= order.filled_quantity

    def get_positions(self) -> List[Position]:
        """Get all positions"""
        return list(self.positions.values())


# ============================================================================
# DEMO ORCHESTRATION
# ============================================================================

class DemoSystem:
    """
    Main demo orchestrator that coordinates all components.
    """

    def __init__(self):
        self.mq = MockMessageQueue()
        self.components = []

    async def run(self, duration_seconds: int = 30):
        """Run the complete demo"""
        print("=" * 80)
        print(" HFT CRYPTOCURRENCY ARBITRAGE SYSTEM - LIVE DEMO")
        print("=" * 80)
        print("\nSystem Architecture:")
        print("  📡 Data Feeds → 📊 Arbitrage Scanner → 📤 Order Manager → 💼 Position Manager")
        print("\nInitializing components...\n")

        # Initialize components
        symbol = "BTCUSDT"

        # Data feeds (simulated exchange connections)
        binance_feed = MockDataFeed(Exchange.BINANCE, symbol, 45000.0, self.mq)
        max_feed = MockDataFeed(Exchange.MAX, symbol, 45050.0, self.mq)  # Start with spread

        # Arbitrage scanner
        scanner = ArbitrageScanner(
            symbol=symbol,
            lead_exchange=Exchange.BINANCE,
            lag_exchange=Exchange.MAX,
            threshold=0.0008,  # 0.08% threshold
            mq=self.mq
        )

        # Order manager
        order_mgr = OrderManager(self.mq)

        # Position manager
        position_mgr = PositionManager(self.mq)

        # Start all components
        await scanner.start()
        await order_mgr.start()
        await position_mgr.start()

        # Start data feeds
        feed_tasks = [
            asyncio.create_task(binance_feed.start()),
            asyncio.create_task(max_feed.start())
        ]

        print("\n" + "=" * 80)
        print(f" SYSTEM RUNNING - Monitoring for {duration_seconds} seconds")
        print("=" * 80)

        # Run for specified duration
        await asyncio.sleep(duration_seconds)

        # Stop feeds
        binance_feed.stop()
        max_feed.stop()

        # Wait for tasks to complete
        for task in feed_tasks:
            task.cancel()
            try:
                await task
            except asyncio.CancelledError:
                pass

        # Print final statistics
        print("\n" + "=" * 80)
        print(" DEMO COMPLETED - SYSTEM STATISTICS")
        print("=" * 80)

        print(f"\n📊 Arbitrage Scanner:")
        print(f"   Signals Generated: {scanner.signals_generated}")
        print(f"   EWMA Spread: {scanner.ewma_spread*100:.4f}%" if scanner.ewma_spread else "   EWMA Spread: N/A")
        if scanner.spread_history:
            print(f"   Avg Spread: {statistics.mean(scanner.spread_history)*100:.4f}%")
            print(f"   Spread Range: {min(scanner.spread_history)*100:.4f}% to {max(scanner.spread_history)*100:.4f}%")

        print(f"\n📤 Order Manager:")
        stats = order_mgr.get_stats()
        print(f"   Orders Filled: {stats['orders_filled']}")
        if stats['orders_filled'] > 0:
            print(f"   Avg Latency: {stats['avg_latency_ms']:.2f}ms")
            print(f"   P50 Latency: {stats['p50_latency_ms']:.2f}ms")
            print(f"   P95 Latency: {stats['p95_latency_ms']:.2f}ms")

        print(f"\n💼 Position Manager:")
        positions = position_mgr.get_positions()
        if positions:
            for pos in positions:
                print(f"   {pos.symbol} ({pos.strategy.value}): {pos.quantity:.2f} @ ${pos.average_price:.2f}")
        else:
            print("   No open positions")

        print(f"\n📨 Message Queue:")
        print(f"   Total Messages: {self.mq.message_count}")
        print(f"   Active Subscriptions: {len(self.mq.subscribers)}")

        print("\n" + "=" * 80)
        print(" Key Features Demonstrated:")
        print("=" * 80)
        print("  ✓ Event-driven architecture with async message queue")
        print("  ✓ Real-time multi-exchange market data processing")
        print("  ✓ EWMA-based arbitrage detection algorithm")
        print("  ✓ Low-latency order execution (50-200ms)")
        print("  ✓ Position tracking and portfolio management")
        print("  ✓ Strongly-typed dataclass messaging")
        print("  ✓ Graceful component lifecycle management")
        print("\n" + "=" * 80)


# ============================================================================
# MAIN ENTRY POINT
# ============================================================================

async def main():
    """Run the demo"""
    demo = DemoSystem()
    await demo.run(duration_seconds=30)


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n\nDemo interrupted by user (Ctrl+C)")
    print("\nThank you for viewing the demo!")
